// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/jmgilman/headjack/internal/prompt"
)

// Ensure, that PrompterMock does implement prompt.Prompter.
// If this is not the case, regenerate this file with moq.
var _ prompt.Prompter = &PrompterMock{}

// PrompterMock is a mock implementation of prompt.Prompter.
//
//	func TestSomethingThatUsesPrompter(t *testing.T) {
//
//		// make and configure a mocked prompt.Prompter
//		mockedPrompter := &PrompterMock{
//			ChoiceFunc: func(prompt string, options []string) (int, error) {
//				panic("mock out the Choice method")
//			},
//			ConfirmFunc: func(title string, description string) (bool, error) {
//				panic("mock out the Confirm method")
//			},
//			PrintFunc: func(message string)  {
//				panic("mock out the Print method")
//			},
//			SecretFunc: func(prompt string) (string, error) {
//				panic("mock out the Secret method")
//			},
//		}
//
//		// use mockedPrompter in code that requires prompt.Prompter
//		// and then make assertions.
//
//	}
type PrompterMock struct {
	// ChoiceFunc mocks the Choice method.
	ChoiceFunc func(prompt string, options []string) (int, error)

	// ConfirmFunc mocks the Confirm method.
	ConfirmFunc func(title string, description string) (bool, error)

	// PrintFunc mocks the Print method.
	PrintFunc func(message string)

	// SecretFunc mocks the Secret method.
	SecretFunc func(prompt string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Choice holds details about calls to the Choice method.
		Choice []struct {
			// Prompt is the prompt argument value.
			Prompt string
			// Options is the options argument value.
			Options []string
		}
		// Confirm holds details about calls to the Confirm method.
		Confirm []struct {
			// Title is the title argument value.
			Title string
			// Description is the description argument value.
			Description string
		}
		// Print holds details about calls to the Print method.
		Print []struct {
			// Message is the message argument value.
			Message string
		}
		// Secret holds details about calls to the Secret method.
		Secret []struct {
			// Prompt is the prompt argument value.
			Prompt string
		}
	}
	lockChoice  sync.RWMutex
	lockConfirm sync.RWMutex
	lockPrint   sync.RWMutex
	lockSecret  sync.RWMutex
}

// Choice calls ChoiceFunc.
func (mock *PrompterMock) Choice(prompt string, options []string) (int, error) {
	if mock.ChoiceFunc == nil {
		panic("PrompterMock.ChoiceFunc: method is nil but Prompter.Choice was just called")
	}
	callInfo := struct {
		Prompt  string
		Options []string
	}{
		Prompt:  prompt,
		Options: options,
	}
	mock.lockChoice.Lock()
	mock.calls.Choice = append(mock.calls.Choice, callInfo)
	mock.lockChoice.Unlock()
	return mock.ChoiceFunc(prompt, options)
}

// ChoiceCalls gets all the calls that were made to Choice.
// Check the length with:
//
//	len(mockedPrompter.ChoiceCalls())
func (mock *PrompterMock) ChoiceCalls() []struct {
	Prompt  string
	Options []string
} {
	var calls []struct {
		Prompt  string
		Options []string
	}
	mock.lockChoice.RLock()
	calls = mock.calls.Choice
	mock.lockChoice.RUnlock()
	return calls
}

// Confirm calls ConfirmFunc.
func (mock *PrompterMock) Confirm(title string, description string) (bool, error) {
	if mock.ConfirmFunc == nil {
		panic("PrompterMock.ConfirmFunc: method is nil but Prompter.Confirm was just called")
	}
	callInfo := struct {
		Title       string
		Description string
	}{
		Title:       title,
		Description: description,
	}
	mock.lockConfirm.Lock()
	mock.calls.Confirm = append(mock.calls.Confirm, callInfo)
	mock.lockConfirm.Unlock()
	return mock.ConfirmFunc(title, description)
}

// ConfirmCalls gets all the calls that were made to Confirm.
// Check the length with:
//
//	len(mockedPrompter.ConfirmCalls())
func (mock *PrompterMock) ConfirmCalls() []struct {
	Title       string
	Description string
} {
	var calls []struct {
		Title       string
		Description string
	}
	mock.lockConfirm.RLock()
	calls = mock.calls.Confirm
	mock.lockConfirm.RUnlock()
	return calls
}

// Print calls PrintFunc.
func (mock *PrompterMock) Print(message string) {
	if mock.PrintFunc == nil {
		panic("PrompterMock.PrintFunc: method is nil but Prompter.Print was just called")
	}
	callInfo := struct {
		Message string
	}{
		Message: message,
	}
	mock.lockPrint.Lock()
	mock.calls.Print = append(mock.calls.Print, callInfo)
	mock.lockPrint.Unlock()
	mock.PrintFunc(message)
}

// PrintCalls gets all the calls that were made to Print.
// Check the length with:
//
//	len(mockedPrompter.PrintCalls())
func (mock *PrompterMock) PrintCalls() []struct {
	Message string
} {
	var calls []struct {
		Message string
	}
	mock.lockPrint.RLock()
	calls = mock.calls.Print
	mock.lockPrint.RUnlock()
	return calls
}

// Secret calls SecretFunc.
func (mock *PrompterMock) Secret(prompt string) (string, error) {
	if mock.SecretFunc == nil {
		panic("PrompterMock.SecretFunc: method is nil but Prompter.Secret was just called")
	}
	callInfo := struct {
		Prompt string
	}{
		Prompt: prompt,
	}
	mock.lockSecret.Lock()
	mock.calls.Secret = append(mock.calls.Secret, callInfo)
	mock.lockSecret.Unlock()
	return mock.SecretFunc(prompt)
}

// SecretCalls gets all the calls that were made to Secret.
// Check the length with:
//
//	len(mockedPrompter.SecretCalls())
func (mock *PrompterMock) SecretCalls() []struct {
	Prompt string
} {
	var calls []struct {
		Prompt string
	}
	mock.lockSecret.RLock()
	calls = mock.calls.Secret
	mock.lockSecret.RUnlock()
	return calls
}
