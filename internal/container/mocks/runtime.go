// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/jmgilman/headjack/internal/container"
)

// Ensure, that RuntimeMock does implement container.Runtime.
// If this is not the case, regenerate this file with moq.
var _ container.Runtime = &RuntimeMock{}

// RuntimeMock is a mock implementation of container.Runtime.
//
//	func TestSomethingThatUsesRuntime(t *testing.T) {
//
//		// make and configure a mocked container.Runtime
//		mockedRuntime := &RuntimeMock{
//			BuildFunc: func(ctx context.Context, cfg *container.BuildConfig) error {
//				panic("mock out the Build method")
//			},
//			ExecFunc: func(ctx context.Context, id string, cfg container.ExecConfig) error {
//				panic("mock out the Exec method")
//			},
//			GetFunc: func(ctx context.Context, id string) (*container.Container, error) {
//				panic("mock out the Get method")
//			},
//			ListFunc: func(ctx context.Context, filter container.ListFilter) ([]container.Container, error) {
//				panic("mock out the List method")
//			},
//			RemoveFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Remove method")
//			},
//			RunFunc: func(ctx context.Context, cfg *container.RunConfig) (*container.Container, error) {
//				panic("mock out the Run method")
//			},
//			StartFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Start method")
//			},
//			StopFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Stop method")
//			},
//		}
//
//		// use mockedRuntime in code that requires container.Runtime
//		// and then make assertions.
//
//	}
type RuntimeMock struct {
	// BuildFunc mocks the Build method.
	BuildFunc func(ctx context.Context, cfg *container.BuildConfig) error

	// ExecFunc mocks the Exec method.
	ExecFunc func(ctx context.Context, id string, cfg container.ExecConfig) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id string) (*container.Container, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, filter container.ListFilter) ([]container.Container, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id string) error

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, cfg *container.RunConfig) (*container.Container, error)

	// StartFunc mocks the Start method.
	StartFunc func(ctx context.Context, id string) error

	// StopFunc mocks the Stop method.
	StopFunc func(ctx context.Context, id string) error

	// calls tracks calls to the methods.
	calls struct {
		// Build holds details about calls to the Build method.
		Build []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cfg is the cfg argument value.
			Cfg *container.BuildConfig
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
			// Cfg is the cfg argument value.
			Cfg container.ExecConfig
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter container.ListFilter
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cfg is the cfg argument value.
			Cfg *container.RunConfig
		}
		// Start holds details about calls to the Start method.
		Start []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
	}
	lockBuild  sync.RWMutex
	lockExec   sync.RWMutex
	lockGet    sync.RWMutex
	lockList   sync.RWMutex
	lockRemove sync.RWMutex
	lockRun    sync.RWMutex
	lockStart  sync.RWMutex
	lockStop   sync.RWMutex
}

// Build calls BuildFunc.
func (mock *RuntimeMock) Build(ctx context.Context, cfg *container.BuildConfig) error {
	if mock.BuildFunc == nil {
		panic("RuntimeMock.BuildFunc: method is nil but Runtime.Build was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cfg *container.BuildConfig
	}{
		Ctx: ctx,
		Cfg: cfg,
	}
	mock.lockBuild.Lock()
	mock.calls.Build = append(mock.calls.Build, callInfo)
	mock.lockBuild.Unlock()
	return mock.BuildFunc(ctx, cfg)
}

// BuildCalls gets all the calls that were made to Build.
// Check the length with:
//
//	len(mockedRuntime.BuildCalls())
func (mock *RuntimeMock) BuildCalls() []struct {
	Ctx context.Context
	Cfg *container.BuildConfig
} {
	var calls []struct {
		Ctx context.Context
		Cfg *container.BuildConfig
	}
	mock.lockBuild.RLock()
	calls = mock.calls.Build
	mock.lockBuild.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *RuntimeMock) Exec(ctx context.Context, id string, cfg container.ExecConfig) error {
	if mock.ExecFunc == nil {
		panic("RuntimeMock.ExecFunc: method is nil but Runtime.Exec was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
		Cfg container.ExecConfig
	}{
		Ctx: ctx,
		ID:  id,
		Cfg: cfg,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(ctx, id, cfg)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedRuntime.ExecCalls())
func (mock *RuntimeMock) ExecCalls() []struct {
	Ctx context.Context
	ID  string
	Cfg container.ExecConfig
} {
	var calls []struct {
		Ctx context.Context
		ID  string
		Cfg container.ExecConfig
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *RuntimeMock) Get(ctx context.Context, id string) (*container.Container, error) {
	if mock.GetFunc == nil {
		panic("RuntimeMock.GetFunc: method is nil but Runtime.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRuntime.GetCalls())
func (mock *RuntimeMock) GetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *RuntimeMock) List(ctx context.Context, filter container.ListFilter) ([]container.Container, error) {
	if mock.ListFunc == nil {
		panic("RuntimeMock.ListFunc: method is nil but Runtime.List was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter container.ListFilter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, filter)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedRuntime.ListCalls())
func (mock *RuntimeMock) ListCalls() []struct {
	Ctx    context.Context
	Filter container.ListFilter
} {
	var calls []struct {
		Ctx    context.Context
		Filter container.ListFilter
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *RuntimeMock) Remove(ctx context.Context, id string) error {
	if mock.RemoveFunc == nil {
		panic("RuntimeMock.RemoveFunc: method is nil but Runtime.Remove was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedRuntime.RemoveCalls())
func (mock *RuntimeMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *RuntimeMock) Run(ctx context.Context, cfg *container.RunConfig) (*container.Container, error) {
	if mock.RunFunc == nil {
		panic("RuntimeMock.RunFunc: method is nil but Runtime.Run was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cfg *container.RunConfig
	}{
		Ctx: ctx,
		Cfg: cfg,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(ctx, cfg)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedRuntime.RunCalls())
func (mock *RuntimeMock) RunCalls() []struct {
	Ctx context.Context
	Cfg *container.RunConfig
} {
	var calls []struct {
		Ctx context.Context
		Cfg *container.RunConfig
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Start calls StartFunc.
func (mock *RuntimeMock) Start(ctx context.Context, id string) error {
	if mock.StartFunc == nil {
		panic("RuntimeMock.StartFunc: method is nil but Runtime.Start was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	return mock.StartFunc(ctx, id)
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedRuntime.StartCalls())
func (mock *RuntimeMock) StartCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *RuntimeMock) Stop(ctx context.Context, id string) error {
	if mock.StopFunc == nil {
		panic("RuntimeMock.StopFunc: method is nil but Runtime.Stop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	return mock.StopFunc(ctx, id)
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//
//	len(mockedRuntime.StopCalls())
func (mock *RuntimeMock) StopCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}
