// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/jmgilman/headjack/internal/catalog"
)

// Ensure, that StoreMock does implement catalog.Store.
// If this is not the case, regenerate this file with moq.
var _ catalog.Store = &StoreMock{}

// StoreMock is a mock implementation of catalog.Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked catalog.Store
//		mockedStore := &StoreMock{
//			AddFunc: func(ctx context.Context, entry *catalog.Entry) error {
//				panic("mock out the Add method")
//			},
//			GetFunc: func(ctx context.Context, id string) (*catalog.Entry, error) {
//				panic("mock out the Get method")
//			},
//			GetByRepoBranchFunc: func(ctx context.Context, repoID string, branch string) (*catalog.Entry, error) {
//				panic("mock out the GetByRepoBranch method")
//			},
//			ListFunc: func(ctx context.Context, filter catalog.ListFilter) ([]catalog.Entry, error) {
//				panic("mock out the List method")
//			},
//			RemoveFunc: func(ctx context.Context, id string) error {
//				panic("mock out the Remove method")
//			},
//			UpdateFunc: func(ctx context.Context, entry *catalog.Entry) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedStore in code that requires catalog.Store
//		// and then make assertions.
//
//	}
type StoreMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(ctx context.Context, entry *catalog.Entry) error

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, id string) (*catalog.Entry, error)

	// GetByRepoBranchFunc mocks the GetByRepoBranch method.
	GetByRepoBranchFunc func(ctx context.Context, repoID string, branch string) (*catalog.Entry, error)

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, filter catalog.ListFilter) ([]catalog.Entry, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, id string) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, entry *catalog.Entry) error

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Entry is the entry argument value.
			Entry *catalog.Entry
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetByRepoBranch holds details about calls to the GetByRepoBranch method.
		GetByRepoBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoID is the repoID argument value.
			RepoID string
			// Branch is the branch argument value.
			Branch string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter catalog.ListFilter
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Entry is the entry argument value.
			Entry *catalog.Entry
		}
	}
	lockAdd             sync.RWMutex
	lockGet             sync.RWMutex
	lockGetByRepoBranch sync.RWMutex
	lockList            sync.RWMutex
	lockRemove          sync.RWMutex
	lockUpdate          sync.RWMutex
}

// Add calls AddFunc.
func (mock *StoreMock) Add(ctx context.Context, entry *catalog.Entry) error {
	if mock.AddFunc == nil {
		panic("StoreMock.AddFunc: method is nil but Store.Add was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Entry *catalog.Entry
	}{
		Ctx:   ctx,
		Entry: entry,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(ctx, entry)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedStore.AddCalls())
func (mock *StoreMock) AddCalls() []struct {
	Ctx   context.Context
	Entry *catalog.Entry
} {
	var calls []struct {
		Ctx   context.Context
		Entry *catalog.Entry
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *StoreMock) Get(ctx context.Context, id string) (*catalog.Entry, error) {
	if mock.GetFunc == nil {
		panic("StoreMock.GetFunc: method is nil but Store.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, id)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedStore.GetCalls())
func (mock *StoreMock) GetCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetByRepoBranch calls GetByRepoBranchFunc.
func (mock *StoreMock) GetByRepoBranch(ctx context.Context, repoID string, branch string) (*catalog.Entry, error) {
	if mock.GetByRepoBranchFunc == nil {
		panic("StoreMock.GetByRepoBranchFunc: method is nil but Store.GetByRepoBranch was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		RepoID string
		Branch string
	}{
		Ctx:    ctx,
		RepoID: repoID,
		Branch: branch,
	}
	mock.lockGetByRepoBranch.Lock()
	mock.calls.GetByRepoBranch = append(mock.calls.GetByRepoBranch, callInfo)
	mock.lockGetByRepoBranch.Unlock()
	return mock.GetByRepoBranchFunc(ctx, repoID, branch)
}

// GetByRepoBranchCalls gets all the calls that were made to GetByRepoBranch.
// Check the length with:
//
//	len(mockedStore.GetByRepoBranchCalls())
func (mock *StoreMock) GetByRepoBranchCalls() []struct {
	Ctx    context.Context
	RepoID string
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		RepoID string
		Branch string
	}
	mock.lockGetByRepoBranch.RLock()
	calls = mock.calls.GetByRepoBranch
	mock.lockGetByRepoBranch.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *StoreMock) List(ctx context.Context, filter catalog.ListFilter) ([]catalog.Entry, error) {
	if mock.ListFunc == nil {
		panic("StoreMock.ListFunc: method is nil but Store.List was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter catalog.ListFilter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	return mock.ListFunc(ctx, filter)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedStore.ListCalls())
func (mock *StoreMock) ListCalls() []struct {
	Ctx    context.Context
	Filter catalog.ListFilter
} {
	var calls []struct {
		Ctx    context.Context
		Filter catalog.ListFilter
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *StoreMock) Remove(ctx context.Context, id string) error {
	if mock.RemoveFunc == nil {
		panic("StoreMock.RemoveFunc: method is nil but Store.Remove was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctx, id)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedStore.RemoveCalls())
func (mock *StoreMock) RemoveCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *StoreMock) Update(ctx context.Context, entry *catalog.Entry) error {
	if mock.UpdateFunc == nil {
		panic("StoreMock.UpdateFunc: method is nil but Store.Update was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Entry *catalog.Entry
	}{
		Ctx:   ctx,
		Entry: entry,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, entry)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedStore.UpdateCalls())
func (mock *StoreMock) UpdateCalls() []struct {
	Ctx   context.Context
	Entry *catalog.Entry
} {
	var calls []struct {
		Ctx   context.Context
		Entry *catalog.Entry
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
