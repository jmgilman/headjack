// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmgilman/headjack/internal/multiplexer"
	"sync"
)

// Ensure, that MultiplexerMock does implement multiplexer.Multiplexer.
// If this is not the case, regenerate this file with moq.
var _ multiplexer.Multiplexer = &MultiplexerMock{}

// MultiplexerMock is a mock implementation of multiplexer.Multiplexer.
//
//	func TestSomethingThatUsesMultiplexer(t *testing.T) {
//
//		// make and configure a mocked multiplexer.Multiplexer
//		mockedMultiplexer := &MultiplexerMock{
//			AttachSessionFunc: func(ctx context.Context, sessionName string) error {
//				panic("mock out the AttachSession method")
//			},
//			CreateSessionFunc: func(ctx context.Context, opts multiplexer.CreateSessionOpts) (*multiplexer.Session, error) {
//				panic("mock out the CreateSession method")
//			},
//			KillSessionFunc: func(ctx context.Context, sessionName string) error {
//				panic("mock out the KillSession method")
//			},
//			ListSessionsFunc: func(ctx context.Context) ([]multiplexer.Session, error) {
//				panic("mock out the ListSessions method")
//			},
//		}
//
//		// use mockedMultiplexer in code that requires multiplexer.Multiplexer
//		// and then make assertions.
//
//	}
type MultiplexerMock struct {
	// AttachSessionFunc mocks the AttachSession method.
	AttachSessionFunc func(ctx context.Context, sessionName string) error

	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, opts multiplexer.CreateSessionOpts) (*multiplexer.Session, error)

	// KillSessionFunc mocks the KillSession method.
	KillSessionFunc func(ctx context.Context, sessionName string) error

	// ListSessionsFunc mocks the ListSessions method.
	ListSessionsFunc func(ctx context.Context) ([]multiplexer.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// AttachSession holds details about calls to the AttachSession method.
		AttachSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionName is the sessionName argument value.
			SessionName string
		}
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts multiplexer.CreateSessionOpts
		}
		// KillSession holds details about calls to the KillSession method.
		KillSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionName is the sessionName argument value.
			SessionName string
		}
		// ListSessions holds details about calls to the ListSessions method.
		ListSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockAttachSession sync.RWMutex
	lockCreateSession sync.RWMutex
	lockKillSession   sync.RWMutex
	lockListSessions  sync.RWMutex
}

// AttachSession calls AttachSessionFunc.
func (mock *MultiplexerMock) AttachSession(ctx context.Context, sessionName string) error {
	if mock.AttachSessionFunc == nil {
		panic("MultiplexerMock.AttachSessionFunc: method is nil but Multiplexer.AttachSession was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		SessionName string
	}{
		Ctx:         ctx,
		SessionName: sessionName,
	}
	mock.lockAttachSession.Lock()
	mock.calls.AttachSession = append(mock.calls.AttachSession, callInfo)
	mock.lockAttachSession.Unlock()
	return mock.AttachSessionFunc(ctx, sessionName)
}

// AttachSessionCalls gets all the calls that were made to AttachSession.
// Check the length with:
//
//	len(mockedMultiplexer.AttachSessionCalls())
func (mock *MultiplexerMock) AttachSessionCalls() []struct {
	Ctx         context.Context
	SessionName string
} {
	var calls []struct {
		Ctx         context.Context
		SessionName string
	}
	mock.lockAttachSession.RLock()
	calls = mock.calls.AttachSession
	mock.lockAttachSession.RUnlock()
	return calls
}

// CreateSession calls CreateSessionFunc.
func (mock *MultiplexerMock) CreateSession(ctx context.Context, opts multiplexer.CreateSessionOpts) (*multiplexer.Session, error) {
	if mock.CreateSessionFunc == nil {
		panic("MultiplexerMock.CreateSessionFunc: method is nil but Multiplexer.CreateSession was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Opts multiplexer.CreateSessionOpts
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, opts)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedMultiplexer.CreateSessionCalls())
func (mock *MultiplexerMock) CreateSessionCalls() []struct {
	Ctx  context.Context
	Opts multiplexer.CreateSessionOpts
} {
	var calls []struct {
		Ctx  context.Context
		Opts multiplexer.CreateSessionOpts
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// KillSession calls KillSessionFunc.
func (mock *MultiplexerMock) KillSession(ctx context.Context, sessionName string) error {
	if mock.KillSessionFunc == nil {
		panic("MultiplexerMock.KillSessionFunc: method is nil but Multiplexer.KillSession was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		SessionName string
	}{
		Ctx:         ctx,
		SessionName: sessionName,
	}
	mock.lockKillSession.Lock()
	mock.calls.KillSession = append(mock.calls.KillSession, callInfo)
	mock.lockKillSession.Unlock()
	return mock.KillSessionFunc(ctx, sessionName)
}

// KillSessionCalls gets all the calls that were made to KillSession.
// Check the length with:
//
//	len(mockedMultiplexer.KillSessionCalls())
func (mock *MultiplexerMock) KillSessionCalls() []struct {
	Ctx         context.Context
	SessionName string
} {
	var calls []struct {
		Ctx         context.Context
		SessionName string
	}
	mock.lockKillSession.RLock()
	calls = mock.calls.KillSession
	mock.lockKillSession.RUnlock()
	return calls
}

// ListSessions calls ListSessionsFunc.
func (mock *MultiplexerMock) ListSessions(ctx context.Context) ([]multiplexer.Session, error) {
	if mock.ListSessionsFunc == nil {
		panic("MultiplexerMock.ListSessionsFunc: method is nil but Multiplexer.ListSessions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSessions.Lock()
	mock.calls.ListSessions = append(mock.calls.ListSessions, callInfo)
	mock.lockListSessions.Unlock()
	return mock.ListSessionsFunc(ctx)
}

// ListSessionsCalls gets all the calls that were made to ListSessions.
// Check the length with:
//
//	len(mockedMultiplexer.ListSessionsCalls())
func (mock *MultiplexerMock) ListSessionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSessions.RLock()
	calls = mock.calls.ListSessions
	mock.lockListSessions.RUnlock()
	return calls
}
