// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"

	"github.com/jmgilman/headjack/internal/git"
)

// Ensure, that RepositoryMock does implement git.Repository.
// If this is not the case, regenerate this file with moq.
var _ git.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of git.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked git.Repository
//		mockedRepository := &RepositoryMock{
//			BranchExistsFunc: func(ctx context.Context, branch string) (bool, error) {
//				panic("mock out the BranchExists method")
//			},
//			CreateWorktreeFunc: func(ctx context.Context, path string, branch string) error {
//				panic("mock out the CreateWorktree method")
//			},
//			IdentifierFunc: func() string {
//				panic("mock out the Identifier method")
//			},
//			ListWorktreesFunc: func(ctx context.Context) ([]git.Worktree, error) {
//				panic("mock out the ListWorktrees method")
//			},
//			RemoveWorktreeFunc: func(ctx context.Context, path string) error {
//				panic("mock out the RemoveWorktree method")
//			},
//			RootFunc: func() string {
//				panic("mock out the Root method")
//			},
//			WorktreeForBranchFunc: func(ctx context.Context, branch string) (string, error) {
//				panic("mock out the WorktreeForBranch method")
//			},
//		}
//
//		// use mockedRepository in code that requires git.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// BranchExistsFunc mocks the BranchExists method.
	BranchExistsFunc func(ctx context.Context, branch string) (bool, error)

	// CreateWorktreeFunc mocks the CreateWorktree method.
	CreateWorktreeFunc func(ctx context.Context, path string, branch string) error

	// IdentifierFunc mocks the Identifier method.
	IdentifierFunc func() string

	// ListWorktreesFunc mocks the ListWorktrees method.
	ListWorktreesFunc func(ctx context.Context) ([]git.Worktree, error)

	// RemoveWorktreeFunc mocks the RemoveWorktree method.
	RemoveWorktreeFunc func(ctx context.Context, path string) error

	// RootFunc mocks the Root method.
	RootFunc func() string

	// WorktreeForBranchFunc mocks the WorktreeForBranch method.
	WorktreeForBranchFunc func(ctx context.Context, branch string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// BranchExists holds details about calls to the BranchExists method.
		BranchExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
		}
		// CreateWorktree holds details about calls to the CreateWorktree method.
		CreateWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Branch is the branch argument value.
			Branch string
		}
		// Identifier holds details about calls to the Identifier method.
		Identifier []struct {
		}
		// ListWorktrees holds details about calls to the ListWorktrees method.
		ListWorktrees []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RemoveWorktree holds details about calls to the RemoveWorktree method.
		RemoveWorktree []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
		}
		// Root holds details about calls to the Root method.
		Root []struct {
		}
		// WorktreeForBranch holds details about calls to the WorktreeForBranch method.
		WorktreeForBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
		}
	}
	lockBranchExists      sync.RWMutex
	lockCreateWorktree    sync.RWMutex
	lockIdentifier        sync.RWMutex
	lockListWorktrees     sync.RWMutex
	lockRemoveWorktree    sync.RWMutex
	lockRoot              sync.RWMutex
	lockWorktreeForBranch sync.RWMutex
}

// BranchExists calls BranchExistsFunc.
func (mock *RepositoryMock) BranchExists(ctx context.Context, branch string) (bool, error) {
	if mock.BranchExistsFunc == nil {
		panic("RepositoryMock.BranchExistsFunc: method is nil but Repository.BranchExists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
	}{
		Ctx:    ctx,
		Branch: branch,
	}
	mock.lockBranchExists.Lock()
	mock.calls.BranchExists = append(mock.calls.BranchExists, callInfo)
	mock.lockBranchExists.Unlock()
	return mock.BranchExistsFunc(ctx, branch)
}

// BranchExistsCalls gets all the calls that were made to BranchExists.
// Check the length with:
//
//	len(mockedRepository.BranchExistsCalls())
func (mock *RepositoryMock) BranchExistsCalls() []struct {
	Ctx    context.Context
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
	}
	mock.lockBranchExists.RLock()
	calls = mock.calls.BranchExists
	mock.lockBranchExists.RUnlock()
	return calls
}

// CreateWorktree calls CreateWorktreeFunc.
func (mock *RepositoryMock) CreateWorktree(ctx context.Context, path string, branch string) error {
	if mock.CreateWorktreeFunc == nil {
		panic("RepositoryMock.CreateWorktreeFunc: method is nil but Repository.CreateWorktree was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Path   string
		Branch string
	}{
		Ctx:    ctx,
		Path:   path,
		Branch: branch,
	}
	mock.lockCreateWorktree.Lock()
	mock.calls.CreateWorktree = append(mock.calls.CreateWorktree, callInfo)
	mock.lockCreateWorktree.Unlock()
	return mock.CreateWorktreeFunc(ctx, path, branch)
}

// CreateWorktreeCalls gets all the calls that were made to CreateWorktree.
// Check the length with:
//
//	len(mockedRepository.CreateWorktreeCalls())
func (mock *RepositoryMock) CreateWorktreeCalls() []struct {
	Ctx    context.Context
	Path   string
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Path   string
		Branch string
	}
	mock.lockCreateWorktree.RLock()
	calls = mock.calls.CreateWorktree
	mock.lockCreateWorktree.RUnlock()
	return calls
}

// Identifier calls IdentifierFunc.
func (mock *RepositoryMock) Identifier() string {
	if mock.IdentifierFunc == nil {
		panic("RepositoryMock.IdentifierFunc: method is nil but Repository.Identifier was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIdentifier.Lock()
	mock.calls.Identifier = append(mock.calls.Identifier, callInfo)
	mock.lockIdentifier.Unlock()
	return mock.IdentifierFunc()
}

// IdentifierCalls gets all the calls that were made to Identifier.
// Check the length with:
//
//	len(mockedRepository.IdentifierCalls())
func (mock *RepositoryMock) IdentifierCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIdentifier.RLock()
	calls = mock.calls.Identifier
	mock.lockIdentifier.RUnlock()
	return calls
}

// ListWorktrees calls ListWorktreesFunc.
func (mock *RepositoryMock) ListWorktrees(ctx context.Context) ([]git.Worktree, error) {
	if mock.ListWorktreesFunc == nil {
		panic("RepositoryMock.ListWorktreesFunc: method is nil but Repository.ListWorktrees was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListWorktrees.Lock()
	mock.calls.ListWorktrees = append(mock.calls.ListWorktrees, callInfo)
	mock.lockListWorktrees.Unlock()
	return mock.ListWorktreesFunc(ctx)
}

// ListWorktreesCalls gets all the calls that were made to ListWorktrees.
// Check the length with:
//
//	len(mockedRepository.ListWorktreesCalls())
func (mock *RepositoryMock) ListWorktreesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListWorktrees.RLock()
	calls = mock.calls.ListWorktrees
	mock.lockListWorktrees.RUnlock()
	return calls
}

// RemoveWorktree calls RemoveWorktreeFunc.
func (mock *RepositoryMock) RemoveWorktree(ctx context.Context, path string) error {
	if mock.RemoveWorktreeFunc == nil {
		panic("RepositoryMock.RemoveWorktreeFunc: method is nil but Repository.RemoveWorktree was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
	}{
		Ctx:  ctx,
		Path: path,
	}
	mock.lockRemoveWorktree.Lock()
	mock.calls.RemoveWorktree = append(mock.calls.RemoveWorktree, callInfo)
	mock.lockRemoveWorktree.Unlock()
	return mock.RemoveWorktreeFunc(ctx, path)
}

// RemoveWorktreeCalls gets all the calls that were made to RemoveWorktree.
// Check the length with:
//
//	len(mockedRepository.RemoveWorktreeCalls())
func (mock *RepositoryMock) RemoveWorktreeCalls() []struct {
	Ctx  context.Context
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
	}
	mock.lockRemoveWorktree.RLock()
	calls = mock.calls.RemoveWorktree
	mock.lockRemoveWorktree.RUnlock()
	return calls
}

// Root calls RootFunc.
func (mock *RepositoryMock) Root() string {
	if mock.RootFunc == nil {
		panic("RepositoryMock.RootFunc: method is nil but Repository.Root was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRoot.Lock()
	mock.calls.Root = append(mock.calls.Root, callInfo)
	mock.lockRoot.Unlock()
	return mock.RootFunc()
}

// RootCalls gets all the calls that were made to Root.
// Check the length with:
//
//	len(mockedRepository.RootCalls())
func (mock *RepositoryMock) RootCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRoot.RLock()
	calls = mock.calls.Root
	mock.lockRoot.RUnlock()
	return calls
}

// WorktreeForBranch calls WorktreeForBranchFunc.
func (mock *RepositoryMock) WorktreeForBranch(ctx context.Context, branch string) (string, error) {
	if mock.WorktreeForBranchFunc == nil {
		panic("RepositoryMock.WorktreeForBranchFunc: method is nil but Repository.WorktreeForBranch was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Branch string
	}{
		Ctx:    ctx,
		Branch: branch,
	}
	mock.lockWorktreeForBranch.Lock()
	mock.calls.WorktreeForBranch = append(mock.calls.WorktreeForBranch, callInfo)
	mock.lockWorktreeForBranch.Unlock()
	return mock.WorktreeForBranchFunc(ctx, branch)
}

// WorktreeForBranchCalls gets all the calls that were made to WorktreeForBranch.
// Check the length with:
//
//	len(mockedRepository.WorktreeForBranchCalls())
func (mock *RepositoryMock) WorktreeForBranchCalls() []struct {
	Ctx    context.Context
	Branch string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
	}
	mock.lockWorktreeForBranch.RLock()
	calls = mock.calls.WorktreeForBranch
	mock.lockWorktreeForBranch.RUnlock()
	return calls
}
